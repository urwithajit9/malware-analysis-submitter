# sqlite3 is only availabe in 2.5+
import os
import sys
import time
import config
if sys.version_info[1] > 4:
    import sqlite3 as sql
else:
    import sqlite as sql

class table(object):
    """ A table in a database.
    Contains attributes name and columns.  The columns are the execute ready sql strings.
    """
    def __init__(self, name, column_list):
        """ Columns are to be the sql, including type and column constraints. """
        self.name = name
        self.columns = column_list

class DB(object):
    def __init__(self):
        """ Constructor.
        Creates the connection to the database.  If the database doesn't already exist,
        creates the tables
        """
        # Check if the file already exists
        create = os.path.exists(config.database_name)
        self.conn = sql.connect(config.database_name) 
        # If the database didn't already exist, create the tables
        if not create:
            self._create_tables()

    def tables(self):
        """ A generator for the database model.  Yeilds table objects. """
        name = 'file'
        columns = ['id INTEGER PRIMARY KEY AUTOINCREMENT', 'name TEXT']
        yield table(name, columns)
        name = 'anubis'
        columns = ['id INTEGER PRIMARY KEY AUTOINCREMENT', 
                   'fid INTEGER REFERENCES file (id)', 
                   'analysis_id TEXT', 
                   'submitted BOOLEAN DEFAULT 0', 
                   'retrieved BOOLEAN DEFAULT 0', 
                   "time REAL DEFAULT 0"]
        yield table(name, columns)
        name = 'cwsandbox'
        columns = ['id INTEGER PRIMARY KEY AUTOINCREMENT', 
                   'fid INTEGER REFERENCES file (id)', 
                   'analysis_id TEXT', 
                   'password TEXT',
                   'submitted BOOLEAN DEFAULT 0', 
                   'retrieved BOOLEAN DEFAULT 0', 
                   "time REAL DEFAULT 0"]
        yield table(name, columns)
        name = 'submission_throttle'
        columns = ['name TEXT PRIMARY KEY',
                   'count INTEGER DEFAULT 0',
                   'time_frame REAL DEFAULT 0',
                   'max INTEGER DEFAULT 0',
                   'reset REAL DEFAULT 0']
        yield table(name, columns)
        name = 'retrieval_throttle'
        columns = ['name TEXT PRIMARY KEY',
                   'count INTEGER DEFAULT 0',
                   'time_frame REAL DEFAULT 0',
                   'max INTEGER DEFAULT 0',
                   'reset REAL DEFAULT 0']
        yield table(name, columns)

    def _create_tables(self):
        """ Create the tables in the database based on self.model. """
        # I know that string formatting is a "bad" way to do this, but the
        # data for this particular query comes from inside this class and not
        # from the user.
        # The first string is the name of the table.
        # The second string is the column list
        create_query = "CREATE TABLE IF NOT EXISTS %s \n(%s)"
        cur = self.conn.cursor()
        for table in self.tables():
            query = create_query%(table.name, ',\n'.join(table.columns))
            cur.execute(query)
        self.conn.commit()
        cur.close()
        self._create_anubis_throttle()
        self._create_cwsandbox_throttle()

    def _create_anubis_throttle(self):
        """ Set up the throttiling information for anubis."""
        sub_query = "INSERT INTO submission_throttle (name, time_frame, max) VALUES ('anubis',?,?)"
        ret_query = "INSERT INTO retrieval_throttle (name, time_frame, max) VALUES ('anubis',?,?)"
        cur = self.conn.cursor()
        cur.execute(sub_query, (config.anubis_submission_time_frame, config.anubis_submission_limit))
        cur.execute(ret_query, (config.anubis_retrieval_time_frame, config.anubis_retrieval_limit))
        self.conn.commit()
        cur.close()

    def _create_cwsandbox_throttle(self):
        """ Set up the throttiling information for cwsandbox."""
        sub_query = "INSERT INTO submission_throttle (name, time_frame, max) VALUES ('cwsandbox',?,?)"
        ret_query = "INSERT INTO retrieval_throttle (name, time_frame, max) VALUES ('cwsandbox',?,?)"
        cur = self.conn.cursor()
        cur.execute(sub_query, (config.cwsandbox_submission_time_frame, config.cwsandbox_submission_limit))
        cur.execute(ret_query, (config.cwsandbox_retrieval_time_frame, config.cwsandbox_retrieval_limit))
        self.conn.commit()
        cur.close()

    def add_file(self, file):
        """ Add file to the database. 
        Default values should be specified by the database schema.
        Returns the fid of the newly created file.  Not that a file with
        the same name already in the database does not generate an error.
        """
        file_insert = "INSERT INTO file (name) VALUES (?)"
        anubis_insert = "INSERT INTO anubis (fid) VALUES (?)"
        cwsandbox_insert = "INSERT INTO cwsandbox (fid) VALUES (?)"
        cur = self.conn.cursor()
        cur.execute(file_insert, (file,))
        fid = cur.lastrowid
        cur.execute(anubis_insert, (fid,))
        cur.execute(cwsandbox_insert, (fid,))
        self.conn.commit()
        cur.close()
        return fid

    def set_anubis_info(self, fid, analysis_id):
        """ Store the anubis report identifying information for file with id fid.
        Also marks the file as submitted to anubis (Assumption is made that the 
        report information can only be obtained through a successful submission.
        """
        query = 'UPDATE anubis SET submitted=1, analysis_id=? WHERE fid=?'
        cur = self.conn.cursor()
        cur.execute(query, (analysis_id, fid))
        self.conn.commit()
        cur.close()

    def set_cwsandbox_info(self, fid, analysis_id, password):
        """ Store the cwsandbox report identifying information for file with id fid.
        Also marks the file as submitted to cwsandbox (Assumption is made that the 
        report information can only be obtained through a successful submission.
        """
        query = 'UPDATE cwsandbox SET submitted=1, analysis_id=?, password=? WHERE fid=?'
        cur = self.conn.cursor()
        cur.execute(query, (analysis_id,password,fid))
        self.conn.commit()
        cur.close()

    def set_anubis_retrieved(self, fid):
        """ Mark that the anubis report for file with id fid has been retrieved"""
        query = 'UPDATE anubis SET retrieved=1 WHERE fid=?'
        cur = self.conn.cursor()
        cur.execute(query, (fid,))
        self.conn.commit()
        cur.close()

    def set_cwsandbox_retrieved(self, fid):
        """ Mark that the cwsandbox report for file with id fid has been retrieved"""
        query = 'UPDATE cwsandbox SET retrieved=1 WHERE fid=?'
        cur = self.conn.cursor()
        cur.execute(query, (fid,))
        self.conn.commit()
        cur.close()

    def all_submitted(self, fid):
        """ Return boolean value indicating if file with id fid has been submitted to all analyzers."""
        query = 'SELECT fid FROM anubis JOIN cwsandbox USING (fid, submitted) WHERE submitted=1 AND fid=?'
        cur = self.conn.cursor()
        cur.execute(query, (fid,))
        result = len(cur.fetchall())
        cur.close()
        return result > 0

    def get_anubis_info(self, fid):
        """ Return the anubis report info for the file with id fid.
        Returns a tuple ready to be unpacked and given to the retrieve function in the interphase.
        If there is no info, return False
        """
        query = "SELECT analysis_id FROM anubis WHERE fid=?"
        cur = self.conn.cursor()
        cur.execute(query, (fid,))
        result = cur.fetchone()
        cur.close()
        if result:
            return result
        else:
            raise Exception('Invalid fid given')
        return result

    def get_cwsandbox_info(self, fid):
        """ Return the cwsandbox report info for the file with id fid.
        Returns a tuple ready to be unpacked and given to the retrieve function in the interphase.
        If there is no info, return False
        """
        query = "SELECT analysis_id,password FROM cwsandbox WHERE fid=?"
        cur = self.conn.cursor()
        cur.execute(query, (fid,))
        result = cur.fetchone()
        cur.close()
        if result:
            return result
        else:
            raise Exception('Invalid fid given')
        
    def get_name(self, fid):
        """Return the name of the file with file id fid"""
        query = "SELECT name from file where id=?"
        cur = self.conn.cursor()
        cur.execute(query, (fid,))
        result = cur.fetchone()
        cur.close()
        if result:
            return result[0]
        else:
            raise Exception('Invalid fid given')

    def get_anubis_submit_queue(self):
        """ Return a list of file id's for files still needing to be submitted to anubis.
        A file will be in this list if it's submitted flag is set to false
        """
        query = 'SELECT fid FROM anubis WHERE submitted=0'
        cur = self.conn.cursor()
        cur.execute(query)
        result = cur.fetchall()
        cur.close()
        result = map(lambda x: x[0], result)
        return result

    def get_cwsandbox_submit_queue(self):
        """ Return a list of file id's for files still needing to be submitted to cwsandbox.
        A file will be in this list if it's submitted flag is set to false
        """
        query = 'SELECT fid FROM cwsandbox WHERE submitted=0'
        cur = self.conn.cursor()
        cur.execute(query)
        result = cur.fetchall()
        cur.close()
        result = map(lambda x: x[0], result)
        return result

    def get_anubis_retrieve_queue(self):
        """ Return a list of file id's for files whose anubis report is ready for retrieving.
        A file will be in this list if it's anubis retrieved flag is set to false, its
        anubis submitted flag is set to true, and the time field indicates that the estimated
        wait time has passed.
        """
        query = 'SELECT fid FROM anubis WHERE retrieved=0 AND time < ?'
        cur = self.conn.cursor()
        cur.execute(query, (time.time(),))
        result = cur.fetchall()
        cur.close()
        result = map(lambda x: x[0], result)
        return result

    def get_cwsandbox_retrieve_queue(self):
        """ Return a list of file id's for files whose cwsandbox report is ready for retrieving.
        A file will be in this list if it's cwsandbox retrieved flag is set to false, its
        cwsandbox submitted flag is set to true, and the time field indicates that the estimated
        wait time has passed.
        """
        query = 'SELECT fid FROM cwsandbox WHERE retrieved=0 AND time < ?'
        cur = self.conn.cursor()
        cur.execute(query, (time.time(),))
        result = cur.fetchall()
        cur.close()
        result = map(lambda x: x[0], result)
        return result

    def remove_if_done(self, fid):
        """ If we are done with the file with id fid, remove it from the database.
        Done is defined as: Flags anubis submitted, anubis retrieved, cwsandbox
        submitted, and cwsandbox retrieved are all true.
        """
        query = 'SELECT fid FROM anubis JOIN cwsandbox USING (fid, submitted, retrieved) WHERE submitted=1 AND retrieved = 1 AND fid=?'
        cur = self.conn.cursor()
        cur.execute(query, (fid,))
        if len(cur.fetchall()) > 0:
            self.remove_file(fid)
        cur.close()

    def remove_file(self, fid):
        """ Remove file with fid from database. """
        remove_file = 'DELETE FROM file WHERE id=?'
        remove_anubis = 'DELETE FROM anubis WHERE fid=?'
        remove_cwsandbox='DELETE FROM cwsandbox WHERE fid=?'
        cur = self.conn.cursor()
        cur.execute(remove_file, (fid,))
        cur.execute(remove_anubis, (fid,))
        cur.execute(remove_cwsandbox, (fid,))
        self.conn.commit()
        cur.close()

    def remove_anubis(self, fid):
        """ Remove file with fid from the anubis table. """
        self.set_anubis_info(fid, 'TO_DELETE')
        self.set_anubis_retrieved(fid)
        self.remove_if_done(fid)

    def remove_cwsandbox(self, fid):
        """ Remove file with fid from the cwsandbox table. """
        self.set_cwsandbox_info(fid, 'TO_DELETE', 'TO_DELETE')
        self.set_cwsandbox_retrieved(fid)
        self.remove_if_done(fid)

    def set_anubis_wait(self, fid, wait):
        """ Set the amount of time to wait before retrieving report with file id fid.
        time is the wait time expressed in seconds.  Can be either floating point or int.
        """
        query = "UPDATE anubis SET time=? WHERE fid=?"
        cur = self.conn.cursor()
        # Set time available to current time plus wait time
        available = time.time() + wait 
        cur.execute(query, (available, fid))
        self.conn.commit()
        cur.close()

    def set_cwsandbox_wait(self, fid, wait):
        """ Set the amount of time to wait before retrieving report with file id fid.
        time is the wait time expressed in seconds.  Can be either floating point or int.
        """
        query = "UPDATE cwsandbox SET time=? WHERE fid=?"
        cur = self.conn.cursor()
        # Set time available to current time plus wait time
        available = time.time() + wait 
        cur.execute(query, (available, fid))
        self.conn.commit()
        cur.close()

    def check_anubis_submission_throttle(self):
        """ Check to make sure that the submission throttle hasn't been passed yet """
        get_reset = "SELECT reset,time_frame FROM submission_throttle WHERE name='anubis'"
        reset = "UPDATE submission_throttle SET count=0, reset=? WHERE name='anubis'"
        query = "SELECT * FROM submission_throttle WHERE name='anubis' AND count <= max"
        cur = self.conn.cursor()
        cur.execute(get_reset)
        next_reset,increment= cur.fetchone()
        if time.time() > next_reset:
            cur.execute(reset, (time.time()+increment,))
            self.conn.commit()
            cur.close()
            return True
        else:
            cur.execute(query)
            result = cur.fetchall()
            cur.close()
            return result

    def check_cwsandbox_submission_throttle(self):
        """ Check to make sure that the submission throttle hasn't been passed yet """
        get_reset = "SELECT reset,time_frame FROM submission_throttle WHERE name='cwsandbox'"
        reset = "UPDATE submission_throttle SET count=0, reset=? WHERE name='cwsandbox'"
        query = "SELECT * FROM submission_throttle WHERE name='cwsandbox' AND count <= max"
        cur = self.conn.cursor()
        cur.execute(get_reset)
        next_reset, increment = cur.fetchone()
        if time.time() > next_reset:
            cur.execute(reset, (time.time()+increment,))
            self.conn.commit()
            cur.close()
            return True
        else:
            cur.execute(query)
            result = cur.fetchall()
            cur.close()
            return result

    def check_anubis_retrieval_throttle(self):
        """ Check to make sure that the retrieval throttle hasn't been passed yet """
        get_reset = "SELECT reset,time_frame FROM retrieval_throttle WHERE name='anubis'"
        reset = "UPDATE retrieval_throttle SET count=0, reset=? WHERE name='anubis'"
        query = "SELECT * FROM retrieval_throttle WHERE name='anubis' AND count <= max"
        cur = self.conn.cursor()
        cur.execute(get_reset)
        next_reset,increment= cur.fetchone()
        if time.time() > next_reset:
            cur.execute(reset, (time.time()+increment,))
            self.conn.commit()
            cur.close()
            return True
        else:
            cur.execute(query)
            result = cur.fetchall()
            cur.close()
            return result

    def check_cwsandbox_retrieval_throttle(self):
        """ Check to make sure that the retrieval throttle hasn't been passed yet """
        get_reset = "SELECT reset,time_frame FROM retrieval_throttle WHERE name='cwsandbox'"
        reset = "UPDATE retrieval_throttle SET count=0, reset=? WHERE name='cwsandbox'"
        query = "SELECT * FROM retrieval_throttle WHERE name='cwsandbox' AND count <= max"
        cur = self.conn.cursor()
        cur.execute(get_reset)
        next_reset, increment = cur.fetchone()
        if time.time() > next_reset:
            cur.execute(reset, (time.time()+increment,))
            self.conn.commit()
            cur.close()
            return True
        else:
            cur.execute(query)
            result = cur.fetchall()
            cur.close()
            return result

    def increment_anubis_submission(self):
        """ Increment the count used for throttling """
        set = "UPDATE submission_throttle SET count=? WHERE name='anubis'"
        get = "SELECT count FROM submission_throttle WHERE name='anubis'"
        cur = self.conn.cursor()
        cur.execute(get)
        count = cur.fetchone()[0]
        cur.execute(set, (count+1,))
        self.conn.commit()
        cur.close()

    def increment_anubis_retrieval(self):
        """ Increment the count used for throttling """
        set = "UPDATE retrieval_throttle SET count=? WHERE name='anubis'"
        get = "SELECT count FROM retrieval_throttle WHERE name='anubis'"
        cur = self.conn.cursor()
        cur.execute(get)
        count = cur.fetchone()[0]
        cur.execute(set, (count+1,))
        self.conn.commit()
        cur.close()

    def increment_cwsandbox_submission(self):
        """ Increment the count used for throttling """
        set = "UPDATE submission_throttle SET count=? WHERE name='cwsandbox'"
        get = "SELECT count FROM submission_throttle WHERE name='cwsandbox'"
        cur = self.conn.cursor()
        cur.execute(get)
        count = cur.fetchone()[0]
        cur.execute(set, (count+1,))
        self.conn.commit()
        cur.close()

    def increment_cwsandbox_retrieval(self):
        """ Increment the count used for throttling """
        set = "UPDATE retrieval_throttle SET count=? WHERE name='cwsandbox'"
        get = "SELECT count FROM retrieval_throttle WHERE name='cwsandbox'"
        cur = self.conn.cursor()
        cur.execute(get)
        count = cur.fetchone()[0]
        cur.execute(set, (count+1,))
        self.conn.commit()
        cur.close()

